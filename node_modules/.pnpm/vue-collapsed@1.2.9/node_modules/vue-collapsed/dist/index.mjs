import { defineComponent as M, toRef as H, computed as f, ref as m, shallowRef as q, onMounted as N, watch as F, openBlock as D, createBlock as P, resolveDynamicComponent as T, normalizeStyle as j, withCtx as E, renderSlot as G, normalizeProps as I, guardReactiveProps as J } from "vue";
const A = "--vc-auto-duration", K = `height var(${A}) cubic-bezier(0.33, 1, 0.68, 1)`, d = { padding: 0 }, L = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", border: "0" };
function R(l) {
  return l.value ? parseFloat(getComputedStyle(l.value).height) : 0;
}
function _(l) {
  var a;
  return { height: `${((a = l.value) == null ? void 0 : a.scrollHeight) ?? 0}px` };
}
function k(l) {
  if (!l.value)
    return {};
  const { transition: a } = getComputedStyle(l.value);
  return a === "all 0s ease 0s" ? { transition: K } : { transition: a };
}
function z(l) {
  if (!l.value)
    return !0;
  const { transition: a } = getComputedStyle(l.value);
  return matchMedia("(prefers-reduced-motion: reduce)").matches || a.includes("none") || a.includes("height 0s");
}
const Q = M({ inheritAttrs: !0, __name: "Collapse", props: { when: { type: Boolean }, baseHeight: { default: 0 }, as: { default: "div" } }, emits: ["collapse", "expand", "collapsed", "expanded"], setup(l, { emit: a }) {
  const p = l, n = H(p, "when"), o = H(p, "baseHeight"), c = f(() => ({ overflow: "hidden", height: `${o.value}px` })), g = f(() => ({ ...d, ...o.value === 0 ? { display: "none" } : c.value })), t = m(null), v = m(n.value ? "expanded" : "collapsed"), s = (e) => v.value = e, h = q({}), i = (e) => h.value = e, r = (e) => i({ ...h.value, ...e }), x = m(300), y = f(() => ({ [A]: `${x.value}ms` }));
  function w() {
    i(d), s("expanded"), a("expanded");
  }
  function C() {
    i(g.value), s("collapsed"), a("collapsed");
  }
  function B(e) {
    var u;
    e.target === t.value && e.propertyName === "height" && (n.value ? ((u = t.value) == null ? void 0 : u.scrollHeight) === R(t) && w() : o.value === R(t) && C());
  }
  return N(() => {
    if (!t.value)
      return;
    n.value || o.value !== 0 || i(L);
    const e = function(b = 0) {
      if (b === 0)
        return 0;
      const $ = b / 36, S = Math.round(10 * (4 + 15 * $ ** 0.25 + $ / 5));
      return Number.isFinite(S) ? S : 0;
    }(t.value.scrollHeight - o.value);
    var u;
    u = e <= 0 ? 300 : e, x.value = u, i(n.value ? d : g.value);
  }), F(n, (e) => {
    if (e) {
      if (z(t))
        return w();
      s("expanding"), a("expand"), i({ ...d, ...c.value, ...y.value }), requestAnimationFrame(() => {
        r({ ..._(t), ...k(t), willChange: "height" });
      });
    } else {
      if (z(t))
        return C();
      s("collapsing"), a("collapse"), r({ ...y.value, ..._(t) }), requestAnimationFrame(() => {
        r({ ...c.value, ...k(t), willChange: "height" });
      });
    }
  }), F(o, (e) => {
    n.value || r(e > 0 ? { display: void 0, height: `${e}px` } : { display: "none" });
  }), (e, u) => (D(), P(T(p.as), { ref_key: "collapseRef", ref: t, style: j(h.value), onTransitionend: B, "data-collapse": v.value }, { default: E(() => [G(e.$slots, "default", I(J({ state: v.value })))]), _: 3 }, 40, ["style", "data-collapse"]));
} });
export {
  Q as Collapse
};
